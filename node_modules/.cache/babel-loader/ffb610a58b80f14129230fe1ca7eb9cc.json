{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // This is a legacy function.\n// Use `findNumbers()` instead.\n\n\nimport { PLUS_CHARS, VALID_PUNCTUATION, VALID_DIGITS, WHITESPACE } from './constants';\nimport { EXTN_PATTERNS_FOR_PARSING } from './extension';\nimport parse from './parse_';\nimport parsePreCandidate from './findNumbers/parsePreCandidate';\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate';\nimport isValidCandidate from './findNumbers/isValidCandidate'; // Copy-pasted from `./parse.js`.\n\nvar VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';\nvar WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+');\nvar PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$'); // // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nvar VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;\nexport default function findPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  var phones = [];\n\n  while (search.hasNext()) {\n    phones.push(search.next());\n  }\n\n  return phones;\n}\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\n\nexport function searchPhoneNumbers(text, options, metadata) {\n  /* istanbul ignore if */\n  if (options === undefined) {\n    options = {};\n  }\n\n  var search = new PhoneNumberSearch(text, options, metadata);\n  return _defineProperty({}, Symbol.iterator, function () {\n    return {\n      next: function next() {\n        if (search.hasNext()) {\n          return {\n            done: false,\n            value: search.next()\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  });\n}\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\n\nexport var PhoneNumberSearch = /*#__PURE__*/function () {\n  // Iteration tristate.\n  function PhoneNumberSearch(text, options, metadata) {\n    _classCallCheck(this, PhoneNumberSearch);\n\n    _defineProperty(this, \"state\", 'NOT_READY');\n\n    this.text = text; // If assigning the `{}` default value is moved to the arguments above,\n    // code coverage would decrease for some weird reason.\n\n    this.options = options || {};\n    this.metadata = metadata;\n    this.regexp = new RegExp(VALID_PHONE_NUMBER + // Phone number extensions\n    '(?:' + EXTN_PATTERNS_FOR_PARSING + ')?', 'ig'); // this.searching_from = 0\n  }\n\n  _createClass(PhoneNumberSearch, [{\n    key: \"find\",\n    value: function find() {\n      var matches = this.regexp.exec(this.text);\n\n      if (!matches) {\n        return;\n      }\n\n      var number = matches[0];\n      var startsAt = matches.index;\n      number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');\n      startsAt += matches[0].length - number.length; // Fixes not parsing numbers with whitespace in the end.\n      // Also fixes not parsing numbers with opening parentheses in the end.\n      // https://github.com/catamphetamine/libphonenumber-js/issues/252\n\n      number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');\n      number = parsePreCandidate(number);\n      var result = this.parseCandidate(number, startsAt);\n\n      if (result) {\n        return result;\n      } // Tail recursion.\n      // Try the next one if this one is not a valid phone number.\n\n\n      return this.find();\n    }\n  }, {\n    key: \"parseCandidate\",\n    value: function parseCandidate(number, startsAt) {\n      if (!isValidPreCandidate(number, startsAt, this.text)) {\n        return;\n      } // Don't parse phone numbers which are non-phone numbers\n      // due to being part of something else (e.g. a UUID).\n      // https://github.com/catamphetamine/libphonenumber-js/issues/213\n      // Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\n\n      if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\n        return;\n      } // // Prepend any opening brackets left behind by the\n      // // `PHONE_NUMBER_START_PATTERN` regexp.\n      // const text_before_number = text.slice(this.searching_from, startsAt)\n      // const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n      // if (full_number_starts_at >= 0)\n      // {\n      // \tnumber   = text_before_number.slice(full_number_starts_at) + number\n      // \tstartsAt = full_number_starts_at\n      // }\n      //\n      // this.searching_from = matches.lastIndex\n\n\n      var result = parse(number, this.options, this.metadata);\n\n      if (!result.phone) {\n        return;\n      }\n\n      result.startsAt = startsAt;\n      result.endsAt = startsAt + number.length;\n      return result;\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      if (this.state === 'NOT_READY') {\n        this.last_match = this.find();\n\n        if (this.last_match) {\n          this.state = 'READY';\n        } else {\n          this.state = 'DONE';\n        }\n      }\n\n      return this.state === 'READY';\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      // Check the state and find the next match as a side-effect if necessary.\n      if (!this.hasNext()) {\n        throw new Error('No next element');\n      } // Don't retain that memory any longer than necessary.\n\n\n      var result = this.last_match;\n      this.last_match = null;\n      this.state = 'NOT_READY';\n      return result;\n    }\n  }]);\n\n  return PhoneNumberSearch;\n}();","map":{"version":3,"sources":["../source/findPhoneNumbers_.js"],"names":["VALID_PHONE_NUMBER","WHITESPACE_IN_THE_BEGINNING_PATTERN","PUNCTUATION_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","options","search","phones","Symbol","next","done","value","PhoneNumberSearch","matches","number","startsAt","parsePreCandidate","result","isValidPreCandidate","isValidCandidate","parse"],"mappings":"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","sourcesContent":["// This is a legacy function.\r\n// Use `findNumbers()` instead.\r\n\r\nimport {\r\n\tPLUS_CHARS,\r\n\tVALID_PUNCTUATION,\r\n\tVALID_DIGITS,\r\n\tWHITESPACE\r\n} from './constants'\r\n\r\nimport { EXTN_PATTERNS_FOR_PARSING } from './extension'\r\n\r\nimport parse from './parse_'\r\n\r\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\r\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\r\nimport isValidCandidate from './findNumbers/isValidCandidate'\r\n\r\n// Copy-pasted from `./parse.js`.\r\nconst VALID_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){3,}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\r\nconst PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$')\r\n\r\n// // Regular expression for getting opening brackets for a valid number\r\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\r\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\r\n\r\nconst VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/\r\n\r\nexport default function findPhoneNumbers(text, options, metadata)\r\n{\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\tconst phones = []\r\n\twhile (search.hasNext()) {\r\n\t\tphones.push(search.next())\r\n\t}\r\n\treturn phones\r\n}\r\n\r\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\r\nexport function searchPhoneNumbers(text, options, metadata)\r\n{\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\r\n\treturn  {\r\n\t\t[Symbol.iterator]() {\r\n\t\t\treturn {\r\n\t    \t\tnext: () => {\r\n\t    \t\t\tif (search.hasNext()) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tdone: false,\r\n\t\t\t\t\t\t\tvalue: search.next()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t    \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\r\nexport class PhoneNumberSearch\r\n{\r\n\t// Iteration tristate.\r\n\tstate = 'NOT_READY'\r\n\r\n\tconstructor(text, options, metadata)\r\n\t{\r\n\t\tthis.text = text\r\n\t\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t\t// code coverage would decrease for some weird reason.\r\n\t\tthis.options = options || {}\r\n\t\tthis.metadata = metadata\r\n\r\n\t\tthis.regexp = new RegExp\r\n\t\t(\r\n\t\t\tVALID_PHONE_NUMBER +\r\n\t\t\t// Phone number extensions\r\n\t\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?',\r\n\t\t\t'ig'\r\n\t\t)\r\n\r\n\t\t// this.searching_from = 0\r\n\t}\r\n\r\n\tfind()\r\n\t{\r\n\t\tconst matches = this.regexp.exec(this.text)\r\n\r\n\t\tif (!matches) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet number   = matches[0]\r\n\t\tlet startsAt = matches.index\r\n\r\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\r\n\t\tstartsAt += matches[0].length - number.length\r\n\t\t// Fixes not parsing numbers with whitespace in the end.\r\n\t\t// Also fixes not parsing numbers with opening parentheses in the end.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/252\r\n\t\tnumber = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '')\r\n\r\n\t\tnumber = parsePreCandidate(number)\r\n\r\n\t\tconst result = this.parseCandidate(number, startsAt)\r\n\r\n\t\tif (result) {\r\n\t\t\treturn result\r\n\t\t}\r\n\r\n\t\t// Tail recursion.\r\n\t\t// Try the next one if this one is not a valid phone number.\r\n\t\treturn this.find()\r\n\t}\r\n\r\n\tparseCandidate(number, startsAt)\r\n\t{\r\n\t\tif (!isValidPreCandidate(number, startsAt, this.text)) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Don't parse phone numbers which are non-phone numbers\r\n\t\t// due to being part of something else (e.g. a UUID).\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/213\r\n\t\t// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\r\n\t\tif (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID'))\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// // Prepend any opening brackets left behind by the\r\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\r\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\r\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\r\n\t\t// if (full_number_starts_at >= 0)\r\n\t\t// {\r\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\r\n\t\t// \tstartsAt = full_number_starts_at\r\n\t\t// }\r\n\t\t//\r\n\t\t// this.searching_from = matches.lastIndex\r\n\r\n\t\tconst result = parse(number, this.options, this.metadata)\r\n\r\n\t\tif (!result.phone) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tresult.startsAt = startsAt\r\n\t\tresult.endsAt   = startsAt + number.length\r\n\r\n\t\treturn result\r\n\t}\r\n\r\n\thasNext()\r\n\t{\r\n\t\tif (this.state === 'NOT_READY')\r\n\t\t{\r\n\t\t\tthis.last_match = this.find()\r\n\r\n\t\t\tif (this.last_match)\r\n\t\t\t{\r\n\t\t\t\tthis.state = 'READY'\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.state = 'DONE'\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.state === 'READY'\r\n\t}\r\n\r\n\tnext()\r\n\t{\r\n\t\t// Check the state and find the next match as a side-effect if necessary.\r\n\t\tif (!this.hasNext())\r\n\t\t{\r\n\t\t\tthrow new Error('No next element')\r\n\t\t}\r\n\r\n\t\t// Don't retain that memory any longer than necessary.\r\n\t\tconst result = this.last_match\r\n\t\tthis.last_match = null\r\n\t\tthis.state = 'NOT_READY'\r\n\t\treturn result\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}